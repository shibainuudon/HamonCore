/**
 *	@file	__output_buffer.hpp
 *
 *	@brief	__output_buffer の定義
 */

#ifndef HAMON_FORMAT___FORMAT___OUTPUT_BUFFER_HPP
#define HAMON_FORMAT___FORMAT___OUTPUT_BUFFER_HPP

#include <hamon/format/__format/__fmt_char_type.hpp>
#include <hamon/format/__format/__max_output_size.hpp>
#include <hamon/algorithm/copy_n.hpp>
#include <hamon/algorithm/min.hpp>
#include <hamon/algorithm/transform.hpp>
#include <hamon/algorithm/fill_n.hpp>
#include <hamon/iterator/back_insert_iterator.hpp>
#include <hamon/iterator/iterator_traits.hpp>
#include <hamon/iterator/concepts/contiguous_iterator.hpp>
#include <hamon/memory/addressof.hpp>
#include <hamon/string_view.hpp>

namespace hamon
{

namespace __format
{

template <__format::__fmt_char_type _CharT>
class __output_buffer
{
public:
	using value_type           = _CharT;
	using __prepare_write_type = void (*)(__output_buffer<_CharT>&, size_t);

	[[nodiscard]]
	explicit __output_buffer(_CharT* __ptr, size_t __capacity, __prepare_write_type __function)
		: __output_buffer {__ptr, __capacity, __function, nullptr} {}

	[[nodiscard]] explicit __output_buffer(
		_CharT* __ptr, size_t __capacity, __prepare_write_type __function, __max_output_size* __max_output_size)
		: __ptr_(__ptr), __capacity_(__capacity), __prepare_write_(__function), __max_output_size_(__max_output_size) {}

	void __buffer_flushed() { __size_ = 0; }

	void __buffer_moved(_CharT* __ptr, size_t __capacity)
	{
		__ptr_      = __ptr;
		__capacity_ = __capacity;
	}

	auto __make_output_iterator() { return hamon::back_insert_iterator{*this}; }

	// Used in hamon::back_insert_iterator.
	void push_back(_CharT __c)
	{
		if (__max_output_size_ && __max_output_size_->__write_request(1) == 0)
		{
			return;
		}

		//_LIBCPP_ASSERT_INTERNAL(
		//	__ptr_ && __size_ < __capacity_ && __available() >= 1, "attempted to write outside the buffer");

		__ptr_[__size_++] = __c;

		// Profiling showed flushing after adding is more efficient than flushing
		// when entering the function.
		if (__size_ == __capacity_)
		{
			__prepare_write(0);
		}
	}

	/// Copies the input __str to the buffer.
	///
	/// Since some of the input is generated by std::to_chars, there needs to be a
	/// conversion when _CharT is wchar_t.
	template <__format::__fmt_char_type _InCharT>
	void __copy(hamon::basic_string_view<_InCharT> __str)
	{
		// When the underlying iterator is a simple iterator the __capacity_ is
		// infinite. For a string or container back_inserter it isn't. This means
		// that adding a large string to the buffer can cause some overhead. In that
		// case a better approach could be:
		// - flush the buffer
		// - container.append(__str.begin(), __str.end());
		// The same holds true for the fill.
		// For transform it might be slightly harder, however the use case for
		// transform is slightly less common; it converts hexadecimal values to
		// upper case. For integral these strings are short.
		// TODO FMT Look at the improvements above.
		size_t __n = __str.size();
		if (__max_output_size_)
		{
			__n = __max_output_size_->__write_request(__n);
			if (__n == 0)
			{
				return;
			}
		}

		const _InCharT* __first = __str.data();
		do
		{
			__prepare_write(__n);
			size_t __chunk = hamon::min(__n, __available());
			hamon::copy_n(__first, __chunk, hamon::addressof(__ptr_[__size_]));
			__size_ += __chunk;
			__first += __chunk;
			__n -= __chunk;
		}
		while (__n);
	}

	/// A std::transform wrapper.
	///
	/// Like @ref __copy it may need to do type conversion.
	template <hamon::contiguous_iterator _Iterator,
		class _UnaryOperation,
		__format::__fmt_char_type _InCharT = typename hamon::iterator_traits<_Iterator>::value_type>
	void __transform(_Iterator __first, _Iterator __last, _UnaryOperation __operation)
	{
		//_LIBCPP_ASSERT_INTERNAL(__first <= __last, "not a valid range");

		size_t __n = static_cast<size_t>(__last - __first);
		if (__max_output_size_)
		{
			__n = __max_output_size_->__write_request(__n);
			if (__n == 0)
			{
				return;
			}
		}

		do
		{
			__prepare_write(__n);
			size_t __chunk = hamon::min(__n, __available());
			hamon::transform(__first, __first + __chunk, hamon::addressof(__ptr_[__size_]), __operation);
			__size_ += __chunk;
			__first += __chunk;
			__n -= __chunk;
		}
		while (__n);
	}

	/// A \c fill_n wrapper.
	void __fill(size_t __n, _CharT __value)
	{
		if (__max_output_size_)
		{
			__n = __max_output_size_->__write_request(__n);
			if (__n == 0)
			{
				return;
			}
		}

		do
		{
			__prepare_write(__n);
			size_t __chunk = hamon::min(__n, __available());
			hamon::fill_n(hamon::addressof(__ptr_[__size_]), __chunk, __value);
			__size_ += __chunk;
			__n -= __chunk;
		}
		while (__n);
	}

	[[nodiscard]] size_t __capacity() const { return __capacity_; }
	[[nodiscard]] size_t __size() const { return __size_; }

private:
	_CharT* __ptr_;
	size_t __capacity_;
	size_t __size_ {0};
	void (*__prepare_write_)(__output_buffer<_CharT>&, size_t);
	__max_output_size* __max_output_size_;

	[[nodiscard]] size_t __available() const { return __capacity_ - __size_; }

	void __prepare_write(size_t __code_units)
	{
		// Always have space for one additional code unit. This is a precondition of the push_back function.
		__code_units += 1;
		if (__available() < __code_units)
		{
			__prepare_write_(*this, __code_units + 1);
		}
	}
};

}	// namespace __format

}	// namespace hamon

#endif // HAMON_FORMAT___FORMAT___OUTPUT_BUFFER_HPP
